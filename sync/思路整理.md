# 思路整理

异步操作系统的目的是在发生I/O时或者出现空闲时进行处理其他应用程序，以充分利用处理器资源。因此能否在内核中实现类似C++20的协程，能够对系统调用进行中断处理，在系统中断中发生I/O操作时进行挂起，优先处理其他的进程。

将内核中的系统调用与线程统一起来，每一个线程不仅拥有用户态的部分，同时也发生在内核态，内核中的协程只对在用户程序处于内核态时进行切换。当任务时间片耗尽时需要切换同样也是发生了时钟中断，进入到内核态的中断后发生切换。（以上描述可能存在误差，有些地方描述的不太合适）

```mermaid
flowchart TB
    subgraph 内核态
        协程切换
        任务1系统调用 --> 协程切换
        任务2系统调用 --> 协程切换
        任务3系统调用 --> 协程切换
    end
    subgraph 用户态
        任务1 --> 任务1系统调用
        任务1系统调用 --> 任务1
        任务2 --> 任务2系统调用
        任务2系统调用 --> 任务2
        任务3 --> 任务3系统调用
        任务3系统调用 --> 任务3
    end
```

协程需要编写者自行确认切换过程出现的相关问题，如果在内核中实现协程，将syscall看做线程的一部分，即可在内核中进行切换。
采用这种方式不需要对应用程序进行更改，只需要对内核函数进行修改即可适配。*(但是在多核中应该怎么做？对每个核心都维护一个协程吗？ 也许在单核中先实现后再考虑)*
当然也可能出现时间片不稳定的问题，目前还没有考虑好，也许在实现后遇到这个问题的全貌。